#!/usr/bin/env python3
"""
tools/11_promote_alias_suggestions.py

Promote accepted alias suggestions into overrides/person_aliases.csv
without manual copy/paste.

Reads:
  - out/person_alias_suggestions.csv   (generated by tools/12_generate_alias_suggestions.py)
Writes/Appends:
  - overrides/person_aliases.csv       (authoritative; applied by 02p5 only when status=verified)

Rules:
  - Never overwrite person_aliases.csv; only append new rows.
  - Deduplicate by alias (case-sensitive exact match).
  - By default, only promote rows where human_decision == 'accept'.
  - If --accept_all is set, promote all rows.

Columns expected in suggestions CSV:
  - alias
  - proposed_person_id
  - person_canon (optional but recommended)

Output person_aliases.csv columns:
  alias,person_id,person_canon,status,notes
"""

from __future__ import annotations

import argparse
import csv
import sys
from pathlib import Path
from typing import Dict

import pandas as pd


def warn(msg: str) -> None:
    print(f"WARN: {msg}", file=sys.stderr)


def info(msg: str) -> None:
    print(f"INFO: {msg}", file=sys.stderr)


def norm(s: str) -> str:
    return " ".join((s or "").strip().split())


def load_existing_registry(path: Path):
    """
    Load existing mappings from overrides/person_aliases.csv.

    Returns:
      - alias_to_pid: normalized alias -> person_id
      - canon_to_pid: normalized person_canon -> person_id
    """
    alias_to_pid = {}
    canon_to_pid = {}

    if not path.exists():
        return alias_to_pid, canon_to_pid

    with path.open("r", encoding="utf-8", newline="") as f:
        r = csv.DictReader(f)
        if not r.fieldnames:
            return alias_to_pid, canon_to_pid

        if "alias" not in r.fieldnames or "person_id" not in r.fieldnames:
            warn(f"{path} missing required headers; cannot dedupe safely.")
            return alias_to_pid, canon_to_pid

        for row in r:
            a = norm(row.get("alias", ""))
            pid = norm(row.get("person_id", ""))
            c = norm(row.get("person_canon", ""))

            if a and pid:
                alias_to_pid[a] = pid
            if c and pid:
                canon_to_pid.setdefault(c, pid)  # first wins

    return alias_to_pid, canon_to_pid


def ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def ensure_person_aliases_header(path: Path) -> None:
    """
    If file doesn't exist, create it with the required header.
    If it exists but empty, also write header.
    """
    if not path.exists():
        ensure_parent(path)
        with path.open("w", encoding="utf-8", newline="") as f:
            w = csv.writer(f)
            w.writerow(["alias", "person_id", "person_canon", "status", "notes"])
        return

    # If exists but zero bytes, write header.
    if path.stat().st_size == 0:
        with path.open("w", encoding="utf-8", newline="") as f:
            w = csv.writer(f)
            w.writerow(["alias", "person_id", "person_canon", "status", "notes"])


def append_rows(path: Path, rows: list[Dict[str, str]]) -> None:
    """
    Append rows to overrides/person_aliases.csv (assumes header exists).
    """
    with path.open("a", encoding="utf-8", newline="") as f:
        w = csv.writer(f)
        for row in rows:
            w.writerow([
                row["alias"],
                row["person_id"],
                row["person_canon"],
                row["status"],
                row.get("notes", ""),
            ])


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--suggestions_csv", default="out/person_alias_suggestions.csv")
    ap.add_argument("--person_aliases_csv", default="overrides/person_aliases.csv")
    ap.add_argument("--accept_all", action="store_true",
                    help="Promote all suggestions regardless of human_decision column.")
    ap.add_argument("--default_status", default="verified",
                    help="Status value to write into person_aliases.csv (default: verified).")
    ap.add_argument("--notes", default="",
                    help="Optional notes string to attach to every promoted row.")
    ap.add_argument("--prefer_existing_person_id", action="store_true",
                    help="If person_canon already exists in person_aliases.csv, reuse its person_id and ignore proposed_person_id.")
    args = ap.parse_args()

    sugg_path = Path(args.suggestions_csv)
    out_path = Path(args.person_aliases_csv)

    if not sugg_path.exists():
        print(f"ERROR: missing {sugg_path} (run tools/12_generate_alias_suggestions.py first)", file=sys.stderr)
        return 2

    df = pd.read_csv(sugg_path)

    required = {"alias", "proposed_person_id"}
    missing = required - set(df.columns)
    if missing:
        print(f"ERROR: suggestions file missing columns: {sorted(missing)}", file=sys.stderr)
        return 2

    # Decide which rows to promote
    if args.accept_all:
        promote = df.copy()
    else:
        if "human_decision" not in df.columns:
            warn("No 'human_decision' column; nothing will be promoted (use --accept_all or add the column).")
            promote = df.iloc[0:0].copy()
        else:
            promote = df[df["human_decision"].fillna("").astype(str).str.strip().str.lower() == "accept"].copy()

    if len(promote) == 0:
        info("No rows to promote.")
        return 0

    # Load existing registry for dedupe
    ensure_person_aliases_header(out_path)
    alias_to_pid, canon_to_pid = load_existing_registry(out_path)

    rows_out: list[Dict[str, str]] = []
    skipped_existing = 0
    skipped_blank = 0

    for _, r in promote.iterrows():
        alias = norm(str(r.get("alias", "")))
        proposed_pid = norm(str(r.get("proposed_person_id", "")))
        canon = norm(str(r.get("person_canon", ""))) or alias

        if not alias or not proposed_pid:
            skipped_blank += 1
            continue

        # 1) If alias already exists, never create a conflicting mapping
        if alias in alias_to_pid:
            existing_pid = alias_to_pid[alias]
            if existing_pid != proposed_pid:
                warn(f"Alias already mapped with different person_id; skipping: alias='{alias}' existing_pid='{existing_pid}' proposed_pid='{proposed_pid}'")
            skipped_existing += 1
            continue

        # 2) If canon already exists, reuse that person_id (prevents split-brain)
        pid = proposed_pid
        if args.prefer_existing_person_id and canon in canon_to_pid:
            pid = canon_to_pid[canon]

        rows_out.append({
            "alias": alias,
            "person_id": pid,
            "person_canon": canon,
            "status": args.default_status,
            "notes": args.notes,
        })

        # update registries so we dedupe within the same run too
        alias_to_pid[alias] = pid
        canon_to_pid.setdefault(canon, pid)

    if not rows_out:
        info(f"Nothing new to append. (skipped_existing={skipped_existing}, skipped_blank={skipped_blank})")
        return 0

    append_rows(out_path, rows_out)
    info(f"Appended {len(rows_out)} rows to {out_path}. "
         f"(skipped_existing={skipped_existing}, skipped_blank={skipped_blank})")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
